define(['js/sylvester','js/style','js/util','js/transformation-chain'],function(a,b,d,c){'use strict';const e=function(e){const f=this.halfEdges[this.faces[e].halfEdge],g=this.halfEdges[f.next],h=this.halfEdges[g.next],i=this.transformedVertices[f.vertex],a=this.transformedVertices[g.vertex],b=this.transformedVertices[h.vertex],c=d.vec.cross(i.subtract(a),i.subtract(b));return d.vec.normalize(c)},f={DooSabinSubdivisionMesh(){this.vertices=[],this.faces=[],this.halfEdges=[],this.transformedVertices=[],this.normals=[],this.init(),this.visibilityTransformationChain=Object.create(c),this.visibilityTransformationChain.TransformationChain(),this.transformationChain=Object.create(c),this.transformationChain.TransformationChain();for(let b=0;b<this.vertices.length;++b)this.transformedVertices.push(a.$V([0,0,0,1]))},init(){this.vertices.push({vector:a.$V([-1,1,-1,1]),halfEdge:0}),this.vertices.push({vector:a.$V([-1,1,1,1]),halfEdge:1}),this.vertices.push({vector:a.$V([1,1,1,1]),halfEdge:2}),this.vertices.push({vector:a.$V([1,1,-1,1]),halfEdge:3}),this.vertices.push({vector:a.$V([-1,-1,1,1]),halfEdge:17}),this.vertices.push({vector:a.$V([-1,-1,-1,1]),halfEdge:21}),this.vertices.push({vector:a.$V([1,-1,-1,1]),halfEdge:22}),this.vertices.push({vector:a.$V([1,-1,1,1]),halfEdge:23}),this.vertices.forEach((a)=>{a.affectedCount=0,a.affectedHalfEdges=[]}),this.faces=[0,4,10,13,16,20].map((a)=>({halfEdge:a})),this.halfEdges=[[1,1,10,0],[2,2,19,0],[3,3,4,0],[0,0,13,0],[2,5,2,1],[7,6,18,1],[6,7,22,1],[3,4,14,1],[4,9,20,2],[1,10,16,2],[0,11,0,2],[5,8,12,0],[0,13,11,3],[3,14,3,3],[6,15,7,3],[5,12,21,3],[4,17,9,4],[7,18,23,4],[2,19,5,4],[1,16,1,4],[5,21,8,5],[6,22,15,5],[7,23,6,5],[4,20,17,5]].map((a)=>{return{vertex:a[0],next:a[1],pair:a[2],face:a[3]}})},update(a,b){this.transformationChain.recalculate(),this.visibilityTransformationChain.recalculate();const c=this.visibilityTransformationChain.getResult();for(let e,f=0;f<this.transformedVertices.length;++f)e=c.multiply(this.vertices[f].vector),e=d.vec.homogenousDivide(e),this.transformedVertices[f]=e;for(let c=0;c<this.faces.length;++c){let a=this.faces[c].halfEdge,b=0;this.faces[c].z=0;do this.faces[c].z=this.transformedVertices[this.halfEdges[a].vertex].elements[2],a=this.halfEdges[a].next,b+=1;while(a!=this.faces[c].halfEdge);this.faces[c].z/=b}const f=[];for(let c,g=0;g<this.faces.length;++g){c=d.vec.sub(a,this.transformedVertices[this.halfEdges[this.faces[g].halfEdge].vertex]),c=d.vec.normalize(c);const h=e.call(this,g);if(0<d.vec.dot(h,c)){let a=d.vec.dot(b,h)+1;a/=2,this.faces[g].shade=a,f.push(g)}}return f},resetTransformedVertices(){for(let a=0;a<this.vertices.length;++a)this.transformedVertices[a]=this.vertices[a].vector.dup()},getStartVertex(a){this.newHalfEdges[a].face;let b,c=a;do b=c,c=this.newHalfEdges[c].next;while(c!=a);return this.newHalfEdges[b].vertex},doSubdivision(){this.edgePoints=[],this.facePoints=[];for(let a=0;a<this.vertices.length;++a)this.vertices[a].affectedCount=0;for(let a=0;a<this.halfEdges.length;++a){const b=this.vertices[this.halfEdges[a].vertex].vector,c=this.vertices[this.halfEdges[this.halfEdges[a].pair].vertex].vector;this.edgePoints.push(c.add(b).multiply(0.5)),this.halfEdges[a].alreadyGeneratedFace=!1}for(let b=0;b<this.faces.length;++b){let c=a.$V([0,0,0,1]),d=this.faces[b].halfEdge,e=0;do{const a=this.vertices[this.halfEdges[d].vertex].vector;e+=1,c=c.add(a),d=this.halfEdges[d].next}while(d!=this.faces[b].halfEdge);c=c.multiply(1/e),c.elements[3]=1,this.facePoints.push(c)}this.newFaces=this.faces.map((a)=>{return Object.assign({},a)}),this.newHalfEdges=this.halfEdges.map((a)=>{return Object.assign({},a)}),this.newVertices=[],this.subdivVertices=[];let b=0;for(let a,b=0;b<this.vertices.length;++b){a=this.vertices[b].halfEdge;do this.vertices[b].affectedCount+=1,this.vertices[b].affectedHalfEdges.push(a),a=this.halfEdges[this.halfEdges[a].pair].next;while(a!=this.vertices[b].halfEdge)}for(let a,c=0;c<this.faces.length;++c){a=this.faces[c].halfEdge;do{let d=this.vertices[this.halfEdges[a].vertex],e=d.vector,f=this.facePoints[c],g=this.edgePoints[a],h=this.halfEdges[a].next,i=this.edgePoints[h],j=e.add(f).add(g).add(i).multiply(0.25);this.newVertices.push({vector:j,halfEdge:this.halfEdges[a].next}),this.newHalfEdges[a].vertex=b,a=this.halfEdges[a].next,b+=1}while(a!=this.faces[c].halfEdge)}let e=this.faces.length,g=this.halfEdges.length;for(let h=0;h<this.halfEdges.length;++h){if(this.newHalfEdges[h].alreadyGeneratedFace)continue;this.newHalfEdges[h].alreadyGeneratedFace=!0,this.newHalfEdges[this.newHalfEdges[h].pair].alreadyGeneratedFace=!0;let i={},a={},b={},c={};i.vertex=this.getStartVertex(h),i.next=g+1,i.face=e,i.pair=h,a.vertex=this.newHalfEdges[this.newHalfEdges[h].pair].vertex,a.next=g+2,a.face=e,a.pair=-1,b.vertex=this.getStartVertex(this.newHalfEdges[h].pair),b.next=g+3,b.face=e,b.pair=this.newHalfEdges[h].pair,c.vertex=this.newHalfEdges[h].vertex,c.next=g,c.face=e,c.pair=-1,this.newHalfEdges.push(i,a,b,c);let d={halfEdge:g};this.newFaces.push(d);let f=this.newHalfEdges[h].pair;this.newHalfEdges[h].pair=g,this.newHalfEdges[f].pair=g+2,g+=4,e+=1}for(let a=0;a<this.vertices.length;++a){let b={halfEdge:g},d=0;for(let b=this.vertices[a].affectedCount-1;0<=b;--b){let c,f=this.newHalfEdges[this.vertices[a].affectedHalfEdges[b]].pair,h=this.newHalfEdges[f].next,i=this.newHalfEdges[h];c=0==b?g:g+d+1;let j={};j.face=e,j.next=c,j.pair=h,j.vertex=this.newHalfEdges[f].vertex,this.newHalfEdges[h].pair=g+d,this.newHalfEdges.push(j),d+=1}g+=this.vertices[a].affectedCount,this.newFaces.push(b),e++}this.vertices=[].concat(this.newVertices),this.vertices.forEach((a)=>{a.affectedCount=0,a.affectedHalfEdges=[]}),this.faces=[].concat(this.newFaces),this.halfEdges=[].concat(this.newHalfEdges),this.transformedVertices=[];for(let b=0;b<this.vertices.length;++b)this.transformedVertices.push(a.$V([0,0,0,1]))}};return f});
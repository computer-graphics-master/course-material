define(['js/sylvester','js/style','js/util','js/transformation-chain','js/lomont-half-edge'],function(a,b,d,c,e){'use strict';var f=Math.floor;const g=function(e){const f=this.transformedVertices[this.faces[e].vertices[0]],a=this.transformedVertices[this.faces[e].vertices[1]],b=this.transformedVertices[this.faces[e].vertices[2]],c=d.vec.cross(f.subtract(a),f.subtract(b));return d.vec.normalize(c)},h={LoopSubdivisionMesh(){this.vertices=[],this.faces=[],this.halfEdges=[],this.transformedVertices=[],this.normals=[],this.init(),this.visibilityTransformationChain=Object.create(c),this.visibilityTransformationChain.TransformationChain(),this.transformationChain=Object.create(c),this.transformationChain.TransformationChain();for(let b=0;b<this.vertices.length;++b)this.transformedVertices.push(a.$V([0,0,0,1]))},init(){this.vertices.push({vector:a.$V([-1,-1,-1,1]),halfEdge:2}),this.vertices.push({vector:a.$V([1,-1,-1,1]),halfEdge:7}),this.vertices.push({vector:a.$V([1,-1,1,1]),halfEdge:3}),this.vertices.push({vector:a.$V([-1,-1,1,1]),halfEdge:33}),this.vertices.push({vector:a.$V([-1,1,-1,1]),halfEdge:6}),this.vertices.push({vector:a.$V([1,1,-1,1]),halfEdge:15}),this.vertices.push({vector:a.$V([1,1,1,1]),halfEdge:12}),this.vertices.push({vector:a.$V([-1,1,1,1]),halfEdge:28}),this.faces=[[0,1,2],[0,2,3],[0,4,1],[1,4,5],[1,6,2],[1,5,6],[5,7,6],[4,7,5],[2,6,3],[3,6,7],[3,7,4],[0,3,4]].map(function(a){return{vertices:a,z:0}}),this.halfEdges=[8,14,3,2,26,33,35,9,0,7,23,15,17,24,1,11,20,12,22,28,16,31,18,10,13,27,4,25,19,30,29,21,34,5,32,6].map((a)=>({pair:a}))},update(a,b){this.transformationChain.recalculate(),this.visibilityTransformationChain.recalculate();const c=this.visibilityTransformationChain.getResult();for(let e,f=0;f<this.transformedVertices.length;++f)e=c.multiply(this.vertices[f].vector),e=d.vec.homogenousDivide(e),this.transformedVertices[f]=e;for(let c=0;c<this.faces.length;++c)this.faces[c].z=this.transformedVertices[this.faces[c].vertices[0]].elements[2]+this.transformedVertices[this.faces[c].vertices[1]].elements[2]+this.transformedVertices[this.faces[c].vertices[2]].elements[2],this.faces[c].z/=3;const e=[];for(let c,f=0;f<this.faces.length;++f){c=d.vec.sub(a,this.transformedVertices[this.faces[f].vertices[0]]),c=d.vec.normalize(c);const h=g.call(this,f);if(0<d.vec.dot(h,c)){let a=d.vec.dot(b,h)+1;a/=2,this.faces[f].shade=a,e.push(f)}}return e},resetTransformedVertices(){for(let a=0;a<this.vertices.length;++a)this.transformedVertices[a]=this.vertices[a].vector.dup()},doSubdivision(){this.newEdgeVertices(),this.updateOriginalVertices(),this.splitFaces(),this.createNewHalfEdgeInfo(),this.vertices=[].concat(this.newVertices),this.faces=[].concat(this.newFaces),this.halfEdges=[].concat(this.newHalfEdges),this.transformedVertices=[];for(let b=0;b<this.vertices.length;++b)this.transformedVertices.push(a.$V([0,0,0,1]))},newEdgeVertices(){this.newVertices=[].concat(this.vertices);this.vertices.length;this.edgeMap=Array(this.halfEdges.length).fill(-1);for(let b=0;b<this.edgeMap.length;++b){if(-1!=this.edgeMap[b])continue;let c={vector:a.$V([0,0,0,1]),halfEdge:0},d=f(b/3),g=this.faces[d].vertices[e.HalfEdge.getEndVertex(b)];c.vector=c.vector.add(this.vertices[g].vector.multiply(3/8));let h=e.HalfEdge.getNextHalfEdge(b);g=this.faces[d].vertices[e.HalfEdge.getEndVertex(h)],c.vector=c.vector.add(this.vertices[g].vector.multiply(1/8));let i=this.halfEdges[b].pair;d=f(i/3),g=this.faces[d].vertices[e.HalfEdge.getEndVertex(i)],c.vector=c.vector.add(this.vertices[g].vector.multiply(3/8)),h=e.HalfEdge.getNextHalfEdge(i),g=this.faces[d].vertices[e.HalfEdge.getEndVertex(h)],c.vector=c.vector.add(this.vertices[g].vector.multiply(1/8)),this.edgeMap[b]=this.newVertices.length,-1!=i&&(this.edgeMap[i]=this.newVertices.length),c.vector.elements[3]=1,this.newVertices.push(c)}},updateOriginalVertices(){for(let b=0;b<this.vertices.length;++b){const c=this.vertices[b].halfEdge;let d=c,g=0,h=a.$V([0,0,0,1]);do{g+=1,d=this.halfEdges[d].pair;const a=f(d/3),b=this.faces[a].vertices[e.HalfEdge.getEndVertex(d)];h=h.add(this.vertices[b].vector),d=3*f(d/3)+(d+2)%3}while(d!=c);h.elements[3]=1;const i=Math.pow(3/8+0.25*Math.cos(6.28318530718/g),2),j=1/g*(5/8-i);h=h.multiply(j);const k=1-g*j;this.newVertices[b].halfEdge=-1,this.newVertices[b].vector=this.vertices[b].vector.multiply(k).add(h),this.newVertices[b].vector.elements[3]=1}this.vertices.forEach((a)=>a.halfEdge=-1)},splitFaces(){this.newFaces=[];for(let a=0;a<this.faces.length;++a){let b=3*a,c=this.faces[a].vertices[0],d=this.faces[a].vertices[1],e=this.faces[a].vertices[2],f=this.edgeMap[b],g=this.edgeMap[b+1],i=this.edgeMap[b+2];this.newFaces.push({vertices:[i,c,f],z:0});let j=3*(this.newFaces.length-1);this.newVertices[i].halfEdge=j+2,this.newVertices[c].halfEdge=j,this.newVertices[f].halfEdge=j+1,this.newFaces.push({vertices:[f,d,g],z:0}),j+=3,this.newVertices[d].halfEdge=j,this.newVertices[g].halfEdge=j+1,this.newFaces.push({vertices:[g,e,i],z:0}),this.newVertices[e].halfEdge=j+3,this.newFaces.push({vertices:[i,f,g],z:0})}},createNewHalfEdgeInfo(){this.newHalfEdges=[];for(let a=0;a<this.faces.length;++a){const c=12*a,b=this.faces[a];this.newHalfEdges.push({pair:this.nIndex(3*a+2,1)}),this.newHalfEdges.push({pair:this.nIndex(3*a,0)}),this.newHalfEdges.push({pair:c+9}),this.newHalfEdges.push({pair:this.nIndex(3*a,1)}),this.newHalfEdges.push({pair:this.nIndex(3*a+1,0)}),this.newHalfEdges.push({pair:c+10}),this.newHalfEdges.push({pair:this.nIndex(3*a+1,1)}),this.newHalfEdges.push({pair:this.nIndex(3*a+2,0)}),this.newHalfEdges.push({pair:c+11}),this.newHalfEdges.push({pair:c+2}),this.newHalfEdges.push({pair:c+5}),this.newHalfEdges.push({pair:c+8})}},nIndex(a,b){const c=this.halfEdges[a].pair;if(-1==c)return-1;const d=12*f(c/3);return d+[3,1,6,4,0,7][2*(c%3)+b]}};return h});
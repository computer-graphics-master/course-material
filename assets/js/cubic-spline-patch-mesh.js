define(['js/sylvester','js/style','js/util','js/transformation-chain'],function(e,a,d,b){'use strict';const f=function(a,b,c,d){return{vertices:a,normals:b,z:0,shade:0,isVisible:!1,colorFront:c,colorBack:d}},c=function(e){const f=this.transformedVertices[this.faces[e].vertices[0]],a=this.transformedVertices[this.faces[e].vertices[1]],b=this.transformedVertices[this.faces[e].vertices[2]],c=d.vec.cross(f.subtract(a),f.subtract(b));return d.vec.normalize(c)},g={CubicSplinePatchMesh(a){this.coefficientMatrix=a,this.transposedCoefficientMatrix=a.transpose(),this.visibilityTransformationChain=Object.create(b),this.visibilityTransformationChain.TransformationChain(),this.transformationChain=Object.create(b),this.transformationChain.TransformationChain();const g=21,c=20;this.faces=[],this.transformedVertices=[],this.normals=[];for(let h=0;h<c;++h)for(let i=0;i<c;++i){const j=h*g+i,a=h*g+i+1,b=(h+1)*g+i,c=(h+1)*g+i+1;this.faces.push(f([j,c,b],[0,0,0],e.$V([0.71,0.28,0.15]),e.$V([0.27,0.53,0.4]))),this.faces.push(f([j,a,c],[0,0,0],e.$V([0.55,0.15,0]),e.$V([1,0.94,0.64]))),this.geometryMatrices=[]}for(let b=0;b<g*g;++b)this.transformedVertices.push(e.$V([0,0,0,1]))},bindControlPoints(a){this.controlPoints=a},setupGeometryMatrices(){this.geometryMatrices=[];for(let a=0;3>a;++a){const b=[];for(let c=0;4>c;++c){const d=[];for(let b=0;4>b;++b)d.push(this.controlPoints[4*c+b].elements[a]);b.push(d)}this.geometryMatrices.push(e.$M(b))}},update(a){this.transformationChain.recalculate(),this.visibilityTransformationChain.recalculate();const b=this.visibilityTransformationChain.getResult();this.vertices=[],this.setupGeometryMatrices();const f=[];for(let b=0;3>b;++b)f.push(this.transposedCoefficientMatrix.multiply(this.geometryMatrices[b]).multiply(this.coefficientMatrix));for(let b=0;1.01>=b;b+=0.05){const a=e.$M([[b*b*b,b*b,b,1]]);for(let b=0;1.01>=b;b+=0.05){const c=e.$V([b*b*b,b*b,b,1]),d=[0,0,0,1];for(let b=0;3>b;++b)d[b]=a.multiply(f[b]).multiply(c).elements[0];this.vertices.push(e.$V(d))}}for(let c,e=0;e<this.vertices.length;++e)c=b.multiply(this.vertices[e]),c=d.vec.homogenousDivide(c),this.transformedVertices[e]=c;for(let b=0;b<this.faces.length;++b)this.faces[b].z=this.transformedVertices[this.faces[b].vertices[0]].elements[2]+this.transformedVertices[this.faces[b].vertices[1]].elements[2]+this.transformedVertices[this.faces[b].vertices[2]].elements[2],this.faces[b].z/=3;const g=[];for(let b,e=0;e<this.faces.length;++e){b=d.vec.sub(a,this.transformedVertices[this.faces[e].vertices[0]]),b=d.vec.normalize(b);const f=c.call(this,e);this.faces[e].shade=1,this.faces[e].isVisible=0<d.vec.dot(f,b),g.push(e)}return g},resetTransformedVertices(){for(let a=0;a<this.vertices.length;++a)this.transformedVertices[a]=this.vertices[a].dup()}};return g});
define(['js/sylvester','js/style','js/util','js/transformation-chain'],function(e,a,d,b){'use strict';const f=function(a,b,c,d){return{vertices:a,normals:b,z:0,shade:0,isVisible:!1,colorFront:c,colorBack:d}},c=function(e){const f=this.transformedVertices[this.faces[e].vertices[0]],a=this.transformedVertices[this.faces[e].vertices[1]],b=this.transformedVertices[this.faces[e].vertices[2]],c=d.vec.cross(f.subtract(a),f.subtract(b));return d.vec.normalize(c)},g=function(a){let b=1;for(let c=a;1<c;--c)b*=c;return b},h=function(a,b){return g(a)/(g(b)*g(a-b))},j=function(a,c,d){var e=Math.pow;const f=h(a,c);return f*e(d,c)*e(1-d,a-c)},i=function(a,b){const c=this.controlPoints[4].subtract(this.controlPoints[0]).multiply(b);let d=e.$V([0,0,0,1]);for(let e=0;4>e;++e){const b=c.add(this.controlPoints[e]).multiply(j(3,e,a));d.elements[0]+=b.elements[0],d.elements[1]+=b.elements[1],d.elements[2]+=b.elements[2]}return d},k={BezierAlongLineMesh(a){this.controlPoints=a,this.visibilityTransformationChain=Object.create(b),this.visibilityTransformationChain.TransformationChain(),this.transformationChain=Object.create(b),this.transformationChain.TransformationChain();const g=21,c=20;this.faces=[],this.transformedVertices=[],this.normals=[];for(let h=0;h<c;++h)for(let i=0;i<c;++i){const j=h*g+i,a=h*g+i+1,b=(h+1)*g+i,c=(h+1)*g+i+1;this.faces.push(f([j,c,b],[0,0,0],e.$V([0.71,0.28,0.15]),e.$V([0.27,0.53,0.4]))),this.faces.push(f([j,a,c],[0,0,0],e.$V([0.55,0.15,0]),e.$V([1,0.94,0.64])))}for(let b=0;b<g*g;++b)this.transformedVertices.push(e.$V([0,0,0,1]))},update(a){this.transformationChain.recalculate(),this.visibilityTransformationChain.recalculate();const b=this.visibilityTransformationChain.getResult();this.vertices=[];for(let b=0;1.01>=b;b+=0.05)for(let a=0;1.01>=a;a+=0.05){const c=i.call(this,b,a);this.vertices.push(c)}for(let c,e=0;e<this.vertices.length;++e)c=b.multiply(this.vertices[e]),c=d.vec.homogenousDivide(c),this.transformedVertices[e]=c;for(let b=0;b<this.faces.length;++b)this.faces[b].z=this.transformedVertices[this.faces[b].vertices[0]].elements[2]+this.transformedVertices[this.faces[b].vertices[1]].elements[2]+this.transformedVertices[this.faces[b].vertices[2]].elements[2],this.faces[b].z/=3;const e=[];for(let b,f=0;f<this.faces.length;++f){b=d.vec.sub(a,this.transformedVertices[this.faces[f].vertices[0]]),b=d.vec.normalize(b);const g=c.call(this,f);this.faces[f].shade=1,this.faces[f].isVisible=0<d.vec.dot(g,b),e.push(f)}return e},resetTransformedVertices(){for(let a=0;a<this.vertices.length;++a)this.transformedVertices[a]=this.vertices[a].dup()}};return k});